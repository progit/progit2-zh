=== 协议

Git 可以使用四种主要的协议来传输数据：本地传输，HTTP 协议，SSH 协议，和Git 协议。
下面分别介绍一下这些协议以及使用（或不使用）这些协议的情形。

==== 本地传输协议

(((protocols, local)))
最基本的就是 _本地协议_（Local protocol），所谓的远程仓库在该协议中的表示，就是硬盘上的另一个目录。
这常见于团队所有成员都对一个共享的网络存储（例如 NFS）拥有访问权，或者比较少见的多人共同登陆到同一台电脑的情况。
后面一种情况并不理想，因为所有代码仓库实例都储存在同一台电脑里，更可能造成灾难性的数据损失。

如果使用一个共享的文件系统，就可以从一个本地基于文件的仓库中克隆、推送和拉取。
这种情况下克隆远程仓库或者为现有本地仓库添加远程仓库只需要使用远程仓库的路径URL。
示例如下：

[source,console]
----
$ git clone /opt/git/project.git
----

或:

[source,console]
----
$ git clone file:///opt/git/project.git
----

如果在 URL 开头显式声明 `file://` ，那么 Git 的运行方式会稍微不一样。
如果只给出路径，Git 会尝试使用硬链接或直接复制它所需要的文件。
如果使用了 `file://` ，Git 会调用它平时通过网络来传输数据的工序，而这种方式的传输效率相对低很多。
使用 `file://` 前缀的主要原因是想抛弃原来仓库的无关引用或对象，来得到一个干净的仓库副本——一般指从其他版本控制系统导入的，或类似情形（参见<<_git_internals>>的维护任务）。
我们这里仅仅使用普通路径，这样更快。

要添加一个本地仓库作为现有 Git 项目的远程仓库，可以这样做：

[source,console]
----
$ git remote add local_proj /opt/git/project.git
----

然后就可以向这个远程远程仓库推送和获取数据了，像通过网络一样。

===== 优点

基于文件的仓库的优点在于它的简单，同时保留了现存的文件权限和网络访问权限。
如果你的团队已经有一个共享的网络存储，建立仓库就十分容易了。
只需把一份裸仓库的副本放在大家都能访问的地方，然后像对其它共享目录一样设置读写权限就可以了。
我们将在下一节 <<_git_on_the_server>> 中讨论如何导出一个裸仓库的副本。

这也是从别人工作仓库中获取工作成果的快捷方法。
假如你和你的同事在一个项目中合作，他们想让你检出一些东西的时候，运行类似 `git pull /home/john/project` 通常会比他们推送到服务器，你再从服务器获取简单得多。

===== 缺点

这种方法的缺点是，与基本的网络连接访问相比，更难以控制访问权限，也更难以从多个位置来访问。
如果想从家里的笔记本电脑上推送，就要先挂载远程硬盘，这和基于网络连接的访问相比更加困难和缓慢。

另一个很重要的问题是该方法不一定就是最快的，尤其是对于共享挂载的文件系统。
本地仓库只有在对数据访问速度快的时候才快。
对同一个服务器而言，如果 NFS 和 SSH 都可以让 Git 访问本地硬盘，通过 NFS 访问仓库通常会比 SSH 慢。

==== HTTP 协议

Git 能使用两种模式通过 HTTP 通讯。
在 Git 1.6.6 之前的版本，只存在一种非常简单的只读方式。
在 Git 1.6.6 中，一种新的智能的协议被引入，这样 Git 就能智能地协商数据传输，类似于它使用 SSH 的方式。
因为它对用户来说更为简单，而且在通讯的时候更智能，在过去的几年中这种新的 HTTP 协议变得非常流行。
这一新协议通常被称为智能 HTTP （Smart HTTP），之前的协议被称为傻瓜 HTTP（Dumb HTTP）。
我们先介绍这种新的智能 HTTP 协议。

===== 智能 HTTP

(((protocols, smart HTTP)))
智能 HTTP 协议在操作上非常类似于 SSH 和 Git 协议，只不过是通过 HTTP/S 端口传输，而且可以使用多样的 HTTP 认证机制。这意味着相对于 SSH，用户使用起来更容易。用户可以使用用户名、密码组合这样的基本认证方式，而不是非得设置 SSH 密钥对。

现在这很可能已经成为使用 Git 最流行的方式了。因为它可以设置为同时接受匿名请求，就像 `git://` 协议；也可以设置为像 SSH 协议一样，通过认证来推送并加密。这两种方式使用同一个 URL 链接，而不是两个不一样的 URL 链接。如果你尝试推送到一个要求认证的仓库（通常它应该这样做），服务器会弹出输入用户名和密码的提示。读取也是一样。

事实上，对于像 GitHub 一样的服务来说，你在线查看仓库的 URL 链接（比如 ``https://github.com/schacon/simplegit[]'' ）就可以用来克隆和推送（如果有相应权限的话）。

===== 傻瓜 HTTP

(((protocols, dumb HTTP)))
如果服务器没有用 Git 智能 HTTP 服务响应，Git客户端会尝试回落到更简单的傻瓜 HTTP 协议。
傻瓜 HTTP 协议把裸 Git 仓库当作那台 Web 服务器上的普通文件处理。
傻瓜 HTTP 协议的美好之处在于设置它非常简单。
基本上，所需要做的一切就是放一个裸 Git 仓库到服务器的 HTTP 文档根目录，设置特定的 `post-update` 钩子，搞定。（参见第 8 章的 <<_git_hooks>>）
到这一阶段，任何有权限访问这台存放仓库的 Web 服务器的人就可以克隆这个仓库了。
如果要开放仓库的只读权限，这样做：

[source,console]
----
$ cd /var/www/htdocs/
$ git clone --bare /path/to/git_project gitproject.git
$ cd gitproject.git
$ mv hooks/post-update.sample hooks/post-update
$ chmod a+x hooks/post-update
----

仅此而已。(((hooks, post-update)))
Git中默认的 `post-update` 钩子会运行恰当的命令（`git update-server-info`）来使 HTTP 抓取和克隆正常运行。
当你推送到这个仓库的时候（或许是通过 SSH），这个命令会运行；之后别人就可以通过类似于下面的方式克隆。

[source,console]
----
$ git clone https://example.com/gitproject.git
----

在这个例子里面，我们使用了 `/var/www/htdocs` 这个路径，这对于 Apache 设定来说是常见的。当然也可以使用任何别的静态 Web 服务器，只需要将裸仓库放到它的路径里。
Git 数据只是被当作简单静态文件（关于更多细节，参见 <<_git_internals>> ）。

大体上来说，你可以选择运行一个可以读写的智能 HTTP 服务器或者简单地将这些文件用傻瓜方式以只读权限发布出去。很少有人同时混合使用这两种方式。

===== 优点

我们着重说智能 HTTP 的优点。

它为所有访问类型使用统一的 URL 链接，而且仅当需要认证时服务器才弹出提示。对最终用户来说，这样使事情变得简单了。
可以使用用户名密码进行认证也是相对于SSH的一个巨大优势。这样用户就不需要为了跟它交互而在本地生成SSH密钥并上传相应的公钥到服务器。
对于不那么老练的用户，或者在一些使用SSH并不普遍的系统上，这是可用性上的一个重大优势。
同时它也是非常迅速且高效的协议，这一点类似于SSH协议。

你也可以通过 HTTPS 提供只读仓库，这意味着可以加密传输内容；或者可以更进一步要求客户端使用特定签名的 SSL 证书。

HTTP/S 还有另外一个好处：它是一个如此常用的协议，以至于企业防火墙通常都设置为允许通过其端口的通信。

===== 缺点

与配置 SSH 相比，在某些服务器上配置使用 HTTP/S 的 Git 可能会更棘手一些。
除此之外，在提供 Git 服务的方面，别的协议相对于智能 HTTP 几乎没有优势。

如果使用 HTTP 来进行认证后推送，倘若凭证的复杂程度超过SSH密钥对的复杂程度，可以使用一些凭证缓存的工具，比如：OS X上的钥匙串访问和Windows上的凭据管理器。这样痛苦就会减轻很多。关于如何设置安全的HTTP凭证存储，参见<<_credential_caching>>。

==== SSH 协议

(((protocols, SSH)))
Git 使用的传输协议中最常见的可能就是 SSH （Secure Shell）了。
这是因为大多数环境已经支持通过 SSH 对服务器的访问 — 即便还没有，架设起来也很容易。
SSH 同时也是一个验证授权的网络协议；而因为其普遍性，架设和使用一般都很容易。

通过 SSH 克隆一个 Git 仓库，可以像下面这样给出 `ssh://` 的 URL：

[source,console]
----
$ git clone ssh://user@server/project.git
----

或者使用更简短的类 SCP 语法：

[source,console]
----
$ git clone user@server:project.git
----

如果不指明用户，Git 会默认使用当前登录的用户名连接服务器。

===== 优点

使用 SSH 的好处有很多。
首先，SSH 相对易于配置——SSH 守护进程很常见，很多网络管理员都有一些使用经验，而且很多操作系统都自带了它或者相关的管理工具。
其次，通过 SSH 进行访问是安全的——所有数据传输都是加密和授权的。
最后，和 HTTP/S、Git 及本地协议一样，SSH 也很高效，会在传输之前尽可能压缩数据。

===== 缺点

SSH 的限制在于不能实现仓库的匿名访问。
即使仅为读取数据，人们也必须在能通过 SSH 访问服务器的前提下才能访问仓库，这使得 SSH 不利于开源的项目。
如果是仅仅在公司网络里使用，SSH 可能是唯一需要使用的协议。
如果想允许对项目的匿名只读访问，那么除了为自己推送而架设 SSH 协议之外，还需要支持其他协议以便他人访问读取。

==== Git 协议

(((protocols, git)))
接下来是 Git 协议。
这是一个包含在 Git 软件包中的特殊守护进程；它会监听一个提供类似于 SSH 服务的专用端口（9418），而无需任何授权。
打算支持 Git 协议的仓库，需要先创建 git-daemon-export-ok 文件——它是协议进程提供仓库服务的必要条件——但除此之外该服务没有什么安全措施。
要么所有人都能克隆 Git 仓库，要么谁也不能。
这也意味着该协议通常不能用来进行推送。
你可以允许推送操作；然而由于没有授权机制，一旦允许该操作，网络上任何一个知道项目 URL 的人将都有推送权限。
不用说，这十分罕见。

===== 优点

Git 协议很多时候是可用的传输协议中最快的。
如果你在提供一个有很大访问量的公共项目，或者一个不需要对读操作进行授权的庞大项目，架设一个 Git 守护进程来供应仓库是个不错的选择。
它使用与 SSH 协议相同的数据传输机制，但省去了加密和授权的开销。

===== 缺点

Git 协议消极的一面是缺少授权机制。
用 Git 协议作为访问项目的唯一方法通常是不可取的。
一般的做法是，同时提供 SSH 或 HTTPS 接口，让几个开发者拥有推送（写）权限，其他人通过 `git://` 拥有只读权限。
Git 协议可能也是最难架设的协议。
它要求有单独的守护进程，需要定制 `xinetd` 之类的配置文件，而这些工作就可能不像闲庭信步一般了。
该协议还要求防火墙开放 9418 端口，而企业级防火墙一般不允许对这个非标准端口的访问。
大型企业级防火墙通常会封锁这个少见的端口。

=== 分支的新建与合并

让我们通过一个分支的新建与合并的例子来演示现实中你可能会使用的一个工作流。
你会按以下步骤做：

. 开发一个网站。
. 为你现在的工作需求创建一个分支。
. 在那个分支上做一些工作。

这种情况下，你接到了一个电话说有一个严重的问题你需要进行一个 hotfix。
你会这样做：

. 切换到你的 production 分支。
. 创建一个分支增加 hotfix。
. 在测试通过后，合并 hotfix 分支，然后推送到 production 分支。
. 切换回你原来的需求分支然后继续工作。

[[_basic_branching]]
==== 新建分支

(((branches, basic workflow)))
首先，我们假设你已经在你的项目上工作并且也有了一些提交。

.一个简单的提交历史
image::images/basic-branching-1.png[一个简单的提交历史。]

你已经决定你要去解决你公司里使用的问题追踪系统中的 issue #53。
创建一个分支并同时切换到它，你可以执行 `git checkout` 命令时增加 `-b` 开关：

[source,console]
----
$ git checkout -b iss53
Switched to a new branch "iss53"
----

这相当于执行下面两条命令：

[source,console]
----
$ git branch iss53
$ git checkout iss53
----

.创建一个新分支指针
image::images/basic-branching-2.png[创建一个新分支指针。]

你在你的网站上工作并做一些提交。
这样做会将 `iss53` 分支向前移动，因为你已经签出它了（就是说，你的 `HEAD` 指向它）

[source,console]
----
$ vim index.html
$ git commit -a -m 'added a new footer [issue 53]'
----

.iss53 分支随工作进展向前推进
image::images/basic-branching-3.png[iss53 分支随工作进展向前推进。]

现在你接到电话说网站上发生了问题，并且你需要马上修复它。
通过 Git，你并不会不得不将修复与 `iss53` 一起部署，并且你不需要做很多努力将之前的修改撤消来应用你的产品的修复。
所有你需要做的就是切换回你的 `master` 分支。

然而，在那样做之前，注意如果你工作目录或暂存区中的与你将要签出分支冲突的未提交修改，Git 不会让你切换分支。
最好在切换分支前有一个干净的工作状态。
我们后面提到有很多方法做到这点（例如，暂存与增量提交），在 <<_git_stashing>>。
现在，让我们假定你已经提交了所有你的修改，所以你可以切换回你的 master 分支。

[source,console]
----
$ git checkout master
Switched to branch 'master'
----

在这时候，你的工程工作目录已经是你开始解决问题 #53 前的状态了，你可以专注于你的 hotfix。
这是需要记住的重要的一点：当你切换分支时，Git 会重置你的工作目录使其看起来像你在那个分支上最后一次提交那样。
它会自动增加、删除、修改文件来保证你的工作拷贝如你在那个分支上最后一次提交那样。

然后，你有一个 hotfix 要做。
让我们创建一个 hotfix 分支工作直到工作完成：

[source,console]
----
$ git checkout -b hotfix
Switched to a new branch 'hotfix'
$ vim index.html
$ git commit -a -m 'fixed the broken email address'
[hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions(+)
----

.基于 `master` 的 Hotfix 分支
image::images/basic-branching-4.png[基于 `master` 的 Hotfix 分支。]

你可以运行你的测试，确保 hotfix 是你想要的，然后将其合并回你的 master 分支来部署到产品中。
你可以使用 `git merge` 命令来这样做：(((git commands, merge)))

[source,console]
----
$ git checkout master
$ git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions(+)
----

你会注意到合并中的短语 ``fast-forward''。
因为你合并的分支所代表的提交是你现在所在提交的直接上游，Git 简单地向前移动了指针。
用另一种说法来说，当你合并一个提交到另一个可以被前面的提交历史到达的提交时，Git 通过向前移动指针来简化事情，因为这样不会有分叉的提交合并到一起 - 这叫作 ``fast-forward.''

你的修改现在在 `master` 分支所指向的提交的快照，现在你可以部署修复了。

.`master` 快进到 `hotfix`
image::images/basic-branching-5.png[`master` 快进到 `hotfix`。]

在你的超级重要的修复部署完后，你准备切换回之前被打断时你正在做的。
然而，首先你需要删除 `hotfix` 分支，因为你不再需要它 - `master` 分支已经指向了同一位置。
你可以使用 `git branch` 的 `-d` 选项来删除它：

[source,console]
----
$ git branch -d hotfix
Deleted branch hotfix (3a0874c).
----

现在你可以切换回你的在问题 #53 的工作中分支并继续工作。

[source,console]
----
$ git checkout iss53
Switched to branch "iss53"
$ vim index.html
$ git commit -a -m 'finished the new footer [issue 53]'
[iss53 ad82d7a] finished the new footer [issue 53]
1 file changed, 1 insertion(+)
----

.继续在 `iss53` 工作
image::images/basic-branching-6.png[继续在 `iss53` 工作。]

在你的 `iss53` 分支上不包含你在 `hotfix` 分支上所做的工作是无意义的。
如果你需要拉入，你可以运行 `git merge master` 将 `master` 分支合并到 `iss53` 分支，或者你可以在直到你决定将 `iss53` 分支合并到 `master` 后再去整合那些修改。

[[_basic_merging]]
==== 分支合并

(((branches, merging)))(((merging)))
假定你的问题 #53 工作已经完成准备合并到 `master` 分支。
为了那样做，你将合并你的 `iss53` 分支，比较像你之前合并你的 `hotfix` 分支。
所有你需要做的是切换到你将要合并到的分支然后运行 `git merge` 命令：

[source,console]
----
$ git checkout master
Switched to branch 'master'
$ git merge iss53
Merge made by the 'recursive' strategy.
README |    1 +
1 file changed, 1 insertion(+)
----

它看起来和你之前合并 `hotfix` 有一点不同。
在这种情况下，你的开发历史从一些以前的点分叉了。
因为当前分支所在的提交并不是你要合并分支的直接祖先，Git 必需要做一些工作。
在这种情况下，Git 做了一个简单的三路合并，使用两个分支所指向的快照和它们共同的祖先。

.一个典型的合并中使用的三个快照
image::images/basic-merging-1.png[一个典型的合并中使用的三个快照。]

Git 通过这次三路合并与自动创建的新提交指向它来产生了一个新的快照，而不只是将分支指针向前快进移动。
这被叫作一次合并提交，它特别在它有一个以上的父结点。

.一次合并提交
image::images/basic-merging-2.png[一次合并提交。]

需要强调的是 Git 选择最好的共同祖先作为它们合并的基础；这与其他的工具如 CVS 或 Subversion（版本 1.5 之前）是不同的，它们需要做合并的开发者自己指出最佳的合并基础。
在 Git 中这使合并变得更容易了相比于其它工具。

现在你的工作已经合并了，你不再需要 `iss53` 分支了。
你可以在问题追踪系统中关闭问题，然后删除分支：

[source,console]
----
$ git branch -d iss53
----

[[_basic_merge_conflicts]]
==== 合并冲突

(((merging, conflicts)))
偶然地，这个过程进行地并不顺利。
如果你修改了你要合并的两个分支中同一个文件的同一个部分，Git 不能干净的合并它们。
如果你修复问题 #53 时修改了 `hotfix` 中文件的同一部分，你会遇到一个合并冲突像下面这样：

[source,console]
----
$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
----

Git 不会自动创建一个新的合并提交。
当你解决冲突时它已经暂停执行。
如果你想要在合并冲突后任意时间查看哪些文件未合并，可以执行 `git status`：

[source,console]
----
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")

Unmerged paths:
  (use "git add <file>..." to mark resolution)

    both modified:      index.html

no changes added to commit (use "git add" and/or "git commit -a")
----

任何有冲突并且未标记已解决的都会列为未合并。
Git 会向冲突文件中增加标准的冲突解决标记，所以你需要手工打开它们并解决那些冲突。
你的文件中包含了像下面这样的部分：

[source,html]
----
<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> iss53:index.html
----

这意味着 `HEAD` 中的版本（你的 `master` 分支，因为那是你在运行合并命令前已经签出的分支）在区块的上方（在 `=======` 标记上方的所有东西），当时 `iss53` 分支看起来所有东西在下方。
为了解决冲突，你不得不选择一边或另一边抑或是你自己合并内容。
例如，你可能会替换整个区块为下面的内容来解决冲突：

[source,html]
----
<div id="footer">
please contact us at email.support@github.com
</div>
----

这个解决方案包含了每一个区块的一部分，并且 `<<<<<<<`、`=======` 与 `>>>>>>>` 标记行都已完全被移除。
当你已经解决完每一个冲突文件的每一个冲突部分，对每一个文件运行 `git add` 来标记为已解决。
在 Git 中暂存文件表示将其标记为已解决。

如果你想要使用图形化工具来解决这些问题，你可以运行 `git mergetool`，将会运行一个合适的可视化合并工作并浏览冲突：(((git commands, mergetool)))

[source,console]
----
$ git mergetool

This message is displayed because 'merge.tool' is not configured.
See 'git mergetool --tool-help' or 'git help config' for more details.
'git mergetool' will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict for 'index.html':
  {local}: modified file
  {remote}: modified file
Hit return to start merge resolution tool (opendiff):
----

如果你想使用非默认的合并工具（因为在 Mac 上运行这个命令所以 Git 选择 `opendiff`），你可以在之后的 ``one of the following tools.'' 章节看到所有列在上方支持的工具。
只需要输入你想要使用的工具的名字。

[NOTE]
====
如果你需要更高级的工具来解决难办的合并冲突，我们将会在 <<_advanced_merging>> 讲解。
====

当你退出合并工具后，Git 询问你合并是否成功。
如果你告诉脚本成功，它将会暂存文件并将其标记为已解决。
你可以再次运行 `git status` 来验证所有的冲突是否都已解决：

[source,console]
----
$ git status
On branch master
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:

    modified:   index.html
----

如果你满意结果，并且你已经验证了所有暂存文件的冲突都已解决，你可以输入 `git commit` 来结束合并提交。
提交信息默认如下面所示：

[source,console]
----
Merge branch 'iss53'

Conflicts:
    index.html
#
# It looks like you may be committing a merge.
# If this is not correct, please remove the file
#	.git/MERGE_HEAD
# and try again.


# Please enter the commit message for your changes. Lines starting
# with '#' will be ignored, and an empty message aborts the commit.
# On branch master
# All conflicts fixed but you are still merging.
#
# Changes to be committed:
#	modified:   index.html
#
----

如果你觉得对其他人在未来查看这次合并有帮助，你可以修改提交信息来增加更多的细节关于你如何解决冲突 - 有时候裁决冲突的理由并不直接或明显，有必要略加注解。

[[_replace]]
=== 替换

Git 对象是不可改变的，但它提供一种有趣的方式来用其他对象假替换数据库中的数个 Git 对象。


`replace`命令可以让你在 Git 中指定一个对象并可以声称“每次你遇到这个 Git 对象时，假装它是其他的东西”。在你的历史中替换一个已有的提交时，这是一个最常用的方法。


例如，你有一个大型的代码历史并想把自己的仓库分成一个短的历史和一个更大更长久的历史，短历史供新的开发者使用，后者给喜欢数据挖掘的人使用。你可以通过最新提交来“替换”早期提交的方式来将一个历史移植到其他历史上。这意味着你不用在新历史中真正替换每一个提交，（历史来源会影响 SHA 的值）你可以加入他们。

让我们来试试吧！首先获取一个已经存在的仓库，并将其分成两个仓库，一个是最近的仓库，一个是历史版本的仓库。然我们将见证在不更改仓库 SHA 值的情况下通过`replace`命令来合并他们。

我们将使用一个拥有5个提交的简单仓库：

[source,console]
----
$ git log --oneline
ef989d8 fifth commit
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

我们想将其分成拆分成两行历史。第一行作为历史版本的仓库包括第一个到第四个提交，第二行作为最近的仓库包括第四、五个提交。

image::images/replace1.png[]

创建历史版本的历史很容易，我们可以只将一个分支放入历史中，然后将这个分支推送到一个新的远程仓库的 master 分支。

[source,console]
----
$ git branch history c6e1e95
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

image::images/replace2.png[]

现在我们可以把这个新的`history`分支推送到我们新仓库的`master`分支：

[source,console]
----
$ git remote add project-history https://github.com/schacon/project-history
$ git push project-history history:master
Counting objects: 12, done.
Delta compression using up to 2 threads.
Compressing objects: 100% (4/4), done.
Writing objects: 100% (12/12), 907 bytes, done.
Total 12 (delta 0), reused 0 (delta 0)
Unpacking objects: 100% (12/12), done.
To git@github.com:schacon/project-history.git
 * [new branch]      history -> master
----

这样一来，我们的历史就发布了。稍难的部分则是截断我们最近的历史。我们需要一个重叠以便于用一个相等的提交来替换另一个提交，这样一来，我们将截断到第四、五个提交。

[source,console]
----
$ git log --oneline --decorate
ef989d8 (HEAD, master) fifth commit
c6e1e95 (history) fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

在这个案例中，创建一个基础提交很有用，这个提交拥有如何扩展历史的命令。这样一来，如果其他的开发者在截断的历史中命中第一个提交或需要更多提交时就知晓做什么了。
因此，接下来我们要做的是用命令创建一个最初的提交对象 ，然后在其上面变基剩下的提交（第四、五个提交）。

为了这么做，我们需要选择一个点去拆分，对于我们而言是第三个提交（ SHA 是`9c68fdc`），因此我们的提交将基于此提交树。我们可以使用`commit-tree`命令来创建基础提交，这样我们就有了一个树，并返回一个全新的、无父节点的 SHA 提交对象。
[source,console]
----
$ echo 'get history from blah blah blah' | git commit-tree 9c68fdc^{tree}
622e88e9cbfbacfb75b5279245b9fb38dfea10cf
----

[NOTE]
=====
`commit-tree`命令属于底层指令。有许多指令并非直接使用，而需通过其他的 Git 命令替换使用。有时当我们做一些像这样的奇怪事情时，Git 允许我们偶尔使用这些底层的命令。想了解更多关于底层命令的内容参见<<_plumbing_porcelain>>
=====

image::images/replace3.png[]

现在我们已经有一个基础提交了，我们可以通过`git rebase --onto`命令来讲其他的历史变基到基础提交之上。`--onto`参数是刚才`commit-tree`命令返回的 SHA 值，变基点则在第三个提交：

[source,console]
----
$ git rebase --onto 622e88 9c68fdc
First, rewinding head to replay your work on top of it...
Applying: fourth commit
Applying: fifth commit
----

image::images/replace4.png[]

我们已经用基础提交重写了最近的历史，基础提交包括如何重新组成整个历史的命令。我们可以将新历史提交到新项目中，当其他人克隆这个仓库时，他们仅能看到最近两次提交以及一个包含命令的的基础提交。

现在我们将以其他人的身份来克隆这个项目。为了在克隆截断后的仓库后得到历史数据，需要添加第二个远程的历史版本库并取回。


[source,console]
----
$ git clone https://github.com/schacon/project
$ cd project

$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git remote add project-history https://github.com/schacon/project-history
$ git fetch project-history
From https://github.com/schacon/project-history
 * [new branch]      master     -> project-history/master
----

现在，合作者在`master`分支中拥有他们最近的提交并且在`project-history/master`分支中拥有过去的提交。

[source,console]
----
$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
622e88e get history from blah blah blah

$ git log --oneline project-history/master
c6e1e95 fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

为了合并他们，你可以使用`git replace`命令加上你想替换的提交信息来进行替换。这样一来，我么就可以将`project-history/master`分支中的第四个提交替换为 master 分支中的第四次提交。

[source,console]
----
$ git replace 81a708d c6e1e95
----

现在，查看`master`分支中的历史信息，显示如下：

[source,console]
----
$ git log --oneline master
e146b5f fifth commit
81a708d fourth commit
9c68fdc third commit
945704c second commit
c1822cf first commit
----

不用改变上游的 SHA 我们就能用一个提交来替换历史中的所有不同的提交，并且所有的工具( bisect , blame 等)也都奏效。

image::images/replace5.png[]

有趣的是，即使是使用了`c6e1e95`提交数据来进行替换，它的 SHA 仍显示为`81a708d`。即使你运行了`cat-file`命令，它仍会显示你替换的数据：

[source,console]
----
$ git cat-file -p 81a708d
tree 7bc544cf438903b65ca9104a1e30345eee6c083d
parent 9c68fdceee073230f19ebb8b5e7fc71b479c0252
author Scott Chacon <schacon@gmail.com> 1268712581 -0700
committer Scott Chacon <schacon@gmail.com> 1268712581 -0700

fourth commit
----

请记住，`81a708d`真正的父提交是`622e882`提交，而非呈现的`9c68fdce`提交。

另一个有趣的事情是数据将会以以下引用显示：

[source,console]
----
$ git for-each-ref
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/heads/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/remotes/history/master
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/HEAD
e146b5f14e79d4935160c0e83fb9ebe526b8da0d commit	refs/remotes/origin/master
c6e1e95051d41771a649f3145423f8809d1a74d4 commit	refs/replace/81a708dd0e167a3f691541c7a6463343bc457040
----

这意味着可以轻而易举的和其他人分享我们的替换，正因为我们可以将替换推送到服务器中，其他人才可以下载到。也许在历史移植情况下不是很有用（既然每个人都能轻松下载到，为何还要拆分他们呢？），但是在其他情况下这种替换方式仍有其广泛的用途。
